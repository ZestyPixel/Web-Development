Closures in javascript are a fundamental concept that allows functions to retain access to their 
lexical scope even when the function is executed outside that scope. 
This means that a function can "remember" the environment in which it was created.

For example:
function outerFunction(outerVariable) {
    return function innerFunction(innerVariable) {
        console.log('Outer Variable: ' + outerVariable);
        console.log('Inner Variable: ' + innerVariable);
    }
}

const newFunction = outerFunction('outside');
newFunction('inside');
In this example, `innerFunction` is a closure that retains access to `outerVariable` even after `outerFunction` has finished executing.
When `newFunction` is called with the argument 'inside', it still has access to 'outside' from its lexical scope.
Closures are commonly used for data privacy, creating function factories, and implementing callbacks.


Example of function factories:
function makeMultiplier(multiplier) {
    return function(value) {
        return value * multiplier;
    }
}

One thing to note is that react batches updates for performance reasons. So if you are updating state multiple times in a single event loop,
only the last update will be applied. Imagine it like this: you write setNum(1) 3 times in a row, react will only apply the last setNum(1) call.

To avoid this, you can use the functional form of the state updater, which takes the previous state as an argument.
So like this:
setNum((prevNum) => prevNum + 1);
This way, each update is based on the most recent state, ensuring that all updates are applied correctly.
